<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Created Characters</title>
  <link rel="stylesheet" href="styles.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
</head>
<body>
  <div class="profilePage">
    <h1 id="profileHeader">
      <span class="tab active" id="myCharactersTab">My Characters</span>
      <span class="separator">|</span>
      <span class="tab" id="myFavoritesTab">My Favorites</span>
    </h1>
    <button onclick="window.location.href='index.html';" class="back-btn">Back</button>
    <div class="sort-controls">
        <div class="menu-toggle" id="menuToggle">
            <i class="fas fa-bars"></i>
        </div>
      <select id="sortOptions">
        <option value="downloads">Downloads</option>
        <option value="likes">Likes</option>
        <option value="comments">Comments</option>
        <option value="favorites">Favorites</option>
        <option value="date">Date Created</option>
      </select>
      <select id="sortOrder">
        <option value="desc">Descending</option>
        <option value="asc">Ascending</option>
      </select>
      <input type="text" id="searchBarCharacters" placeholder="Search..." />
    </div>
    <div id="detailsPanelPlace"></div>
    <div class="container-profile">
      <div class="character-grid" id="characterGrid">Loading characters...</div>
    </div>
  </div>
  <!-- Overlay element for mobile sidebar -->
  <div class="overlay" id="overlay"></div>
  <script type="module">
    import { populateGrid } from './characterGrid.js';
    
    // Parse the URL parameters
    const params = new URLSearchParams(window.location.search);
    const userID = params.get('u');
    const charID = params.get("charID");
    window.history.replaceState({}, document.title, "profile.html");
    let currentType = null;
    // Fetch profile user data
    let profileUser = null;
    try {
      if (userID) {
        const response = await fetch(`https://chatcord-server.onrender.com/get-user/${userID}`);
        if (!response.ok) throw new Error("Failed to fetch profile user");
        const data = await response.json();
        profileUser = data.user;
      }
    } catch (error) {
      console.error("Error fetching profile user:", error);
    }
    // Get user data
    const user = JSON.parse(localStorage.getItem("user")) || {};
    let accessLevel = null;
    
    if (user.id) {
      try {
        const userResponse = await fetch(`https://chatcord-server.onrender.com/get-user/${user.id}`);
        const userData = await userResponse.json();
        accessLevel = userData.user?.access_level?.toLowerCase();
      } catch (error) {
        console.error("Error fetching user data:", error);
      }
    }

    // Set up UI based on whether viewing own profile or someone else's
    const header = document.getElementById('profileHeader');
    if (profileUser) {
      // Viewing someone else's profile
      const displayName = profileUser.displayname && profileUser.displayname.trim() !== ""
      ? profileUser.displayname
      : profileUser.username;
      header.innerHTML = `<span>${displayName}'s Profile</span>`;
    } else {
      // Viewing own profile
      if (accessLevel === 'admin' || accessLevel === 'moderator') {
        const separator = document.createElement('span');
        separator.className = 'separator';
        separator.textContent = '|';
        
        const forReviewTab = document.createElement('span');
        forReviewTab.className = 'tab';
        forReviewTab.id = 'forReviewTab';
        forReviewTab.textContent = 'For Review';
        forReviewTab.addEventListener('click', () => loadCharacters('review', accessLevel));
        
        header.appendChild(separator);
        header.appendChild(forReviewTab);
      }
    }

    // Tab click handler
    function handleTabClick(tabElement, type) {
      // Remove active class from all tabs
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      // Add active class to clicked tab
      tabElement.classList.add('active');
      // Load characters
      loadCharacters(type, accessLevel);
    }

    // Set up tab event listeners
    if (!userID) {
      document.getElementById('myCharactersTab').addEventListener('click', () => {
        handleTabClick(document.getElementById('myCharactersTab'), 'mine');
      });
    
      document.getElementById('myFavoritesTab').addEventListener('click', () => {
        handleTabClick(document.getElementById('myFavoritesTab'), 'favorites');
      });
      
      if (document.getElementById('forReviewTab')) {
        document.getElementById('forReviewTab').addEventListener('click', () => {
          handleTabClick(document.getElementById('forReviewTab'), 'review');
        });
      }
    }

    // Main character loading function
    async function loadCharacters(type, accessLevel) {
    try {
      document.getElementById('characterGrid').innerHTML = "Loading...";
  
      // 1) Fetch all characters with error handling
      let allCharacters = [];
      try {
        const respChars = await fetch('https://chatcord-server.onrender.com/get-characters');
        if (respChars.ok) {
          const data = await respChars.json();
          allCharacters = Array.isArray(data) ? data : [];
        } else {
          console.error(`HTTP error: ${respChars.status}`);
        }
      } catch (error) {
        console.error('Fetch failed:', error);
      }
  
      // 2) Get the ids of favortited characters
      const myUserId = user?.id ?? null;
      
      // Search setup
      const searchInput = document.getElementById("searchBarCharacters");
      let searchQuery = searchInput.value.toLowerCase();

      let favoriteCharacterIds = new Set();
      if (myUserId && (type === 'favorites' || type === 'mine')) {
        try {
          const respInter = await fetch(
            `https://chatcord-server.onrender.com/user-interactions/${myUserId}`
          );
          const interactions = await respInter.json();
          interactions.forEach(({ character_id }) => {
            favoriteCharacterIds.add(Number(character_id));
          });
        } catch (error) {
          console.error('Failed to fetch interactions:', error);
        }
      }
  
      // 3) Filter characters (now safe with array)
      let charactersToDisplay = allCharacters.filter(character => {
        if (type !== 'mine' && type !== 'review' && character.review_status !== 'approved') {
          return false;
        }
        switch (type) {
          case 'mine': return character.userID === myUserId;
          case 'favorites': return favoriteCharacterIds.has(Number(character.id));
          case 'review': return character.review_status === 'pending';
          case 'user': return character.username === profileUser.username;
          default: return true;
        }
      });
      
      // Find matching character for initial search input
      const matchedChar = charactersToDisplay.find(char => char.id === charID);
      if (charID && matchedChar) {
        searchInput.value = matchedChar.char_name;
        searchQuery = matchedChar.char_name.toLowerCase();
      }
  
      // Filter characters
      let filteredCharacters = charactersToDisplay.filter(char => {
        // const isApproved = (char.review_status || "").toLowerCase() === "approved";
        const matchesSearch = char.char_name?.toLowerCase().includes(searchQuery);
        // Admins and mods can always see everything
        const isStaff = accessLevel === 'admin' || accessLevel === 'moderator';
        // Private check
        const canViewPrivate =
          isStaff ||                 // staff override
          !char.is_private ||        // not private
          char.userID === myUserId || // owner
          char.id === charID;        // accessed directly by ID
        // return isApproved && (searchQuery === "" || matchesSearch);
        return canViewPrivate && (searchQuery === "" || matchesSearch);
      });
  
      // Sorting
      const sortOption = document.getElementById("sortOptions").value;
      const sortOrder = document.getElementById("sortOrder").value;
      const multiplier = sortOrder === "asc" ? -1 : 1;
  
      filteredCharacters.sort((charA, charB) => {
        const getValue = (char, field) => parseInt(char[field], 10) || 0;
        
        switch (sortOption) {
          case "downloads":
            return multiplier * (getValue(charB, 'downloads') - getValue(charA, 'downloads'));
          case "likes":
            return multiplier * (getValue(charB, 'likes') - getValue(charA, 'likes'));
          case "comments":
            return multiplier * (getValue(charB, 'comments') - getValue(charA, 'comments'));
          case "favorites":
            return multiplier * (getValue(charB, 'favorites') - getValue(charA, 'favorites'));
          case "date":
            return multiplier * (new Date(charB.createdAt) - new Date(charA.createdAt));
          default:
            return 0;
        }
      });
  
      // 4) Sorting and rendering
      if (type === 'mine') {
        filteredCharacters.sort((a, b) => {
          if (a.review_status === 'request_changes') return -1;
          if (b.review_status === 'request_changes') return 1;
          return 0;
        });
      }
  
      const showFavBadge = (type === 'favorites');
      if (filteredCharacters.length === 0) {
        document.getElementById('characterGrid').innerHTML = 
           type === 'favorites' ? "You haven't favorited any characters yet." :
           type === 'mine' ? "You haven't created any characters yet." :
           type === 'review' ? "No characters pending review." :
           "No characters found.";
      } else {
        populateGrid(filteredCharacters, {
          showDetails: type !== 'mine',
          reviewMode: type === 'review',
          accessLevel: accessLevel,
          includeTags: [],
          excludeTags: []
        });
      }
    } catch (error) {
      console.error("Error loading characters:", error);
      document.getElementById('characterGrid').innerText = "Failed to load characters.";
    }
  }
    // Initial load
    if (userID) {
      // Viewing someone else's profile
      currentType = 'user';
      await loadCharacters(currentType, accessLevel);
    } else {
      // Viewing own profile
      if (accessLevel === 'admin' || accessLevel === 'moderator') {
        currentType = 'review';
        await loadCharacters(currentType, accessLevel);
        document.getElementById('forReviewTab').classList.add('active');
      } else {
        currentType = 'mine';
        await loadCharacters(currentType, accessLevel);
        document.getElementById('myCharactersTab').classList.add('active');
      }
    }

    // Character grid search bar
    document.getElementById("searchBarCharacters").addEventListener("input", () => {
      charID = null;
      loadCharacters(currentType, accessLevel);
    });
    document.getElementById("sortOptions").addEventListener("input", () => {
      loadCharacters(currentType, accessLevel);
    });
    document.getElementById("sortOrder").addEventListener("input", () => {
      loadCharacters(currentType, accessLevel);
    });
    
    // Close sidebar when clicking on the overlay
    document.getElementById('overlay').addEventListener('click', function() {
      document.getElementById('detailsPanel')?.remove();
      this.classList.remove('active');
    });

  </script>
</body>
</html>
