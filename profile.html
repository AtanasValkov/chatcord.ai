<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Created Characters</title>
  <link rel="stylesheet" href="styles.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
</head>
<body>
  <div class="profilePage">
    <div id="profileHeaderWrap">
      <h1 id="profileHeader">
        <span class="tab active" id="myCharactersTab">My Characters</span>
        <span class="separator">|</span>
        <span class="tab" id="myFavoritesTab">My Favorites</span>
      </h1>
      <div id="profileHeaderMeta" aria-hidden="false"></div>
    </div>
    <button onclick="window.location.href='index.html';" class="back-btn">Back</button>
    <div class="sort-controls">
        <div class="menu-toggle" id="menuToggle">
            <i class="fas fa-bars"></i>
        </div>
      <select id="sortOptions">
        <option value="downloads">Downloads</option>
        <option value="likes">Likes</option>
        <option value="comments">Comments</option>
        <option value="favorites">Favorites</option>
        <option value="date">Date Created</option>
      </select>
      <select id="sortOrder">
        <option value="desc">Descending</option>
        <option value="asc">Ascending</option>
      </select>
      <input type="text" id="searchBarCharacters" placeholder="Search..." />
    </div>
    <div id="detailsPanelPlace"></div>
    <div class="container-profile">
      <div class="character-grid" id="characterGrid">Loading characters...</div>
    </div>
  </div>
  <!-- Overlay element for mobile sidebar -->
  <div class="overlay" id="overlay"></div>
  <script type="module">
    import { populateGrid } from './characterGrid.js';
    
    // Parse the URL parameters
    const params = new URLSearchParams(window.location.search);
    const userID = params.get('u');
    let charID = params.get("charID");
    window.history.replaceState({}, document.title, "profile.html");
    let currentType = null;
    // Fetch profile user data
    let profileUser = null;
    try {
      if (userID) {
        const response = await fetch(`https://chatcord-server.onrender.com/get-user/${userID}`);
        if (!response.ok) throw new Error("Failed to fetch profile user");
        const data = await response.json();
        profileUser = data.user;
      }
    } catch (error) {
      console.error("Error fetching profile user:", error);
    }
    // Get user data
    const user = JSON.parse(localStorage.getItem("user")) || {};
    const myUserId = user.id ?? null;
    let accessLevel = null;
    
    if (myUserId) {
      try {
        const userResponse = await fetch(`https://chatcord-server.onrender.com/get-user/${myUserId}`);
        const userData = await userResponse.json();
        accessLevel = userData.user?.access_level?.toLowerCase();
      } catch (error) {
        console.error("Error fetching user data:", error);
      }
    }
    
    // Set up UI based on whether viewing own profile or someone else's
    const header = document.getElementById('profileHeader');
    // Fetch profile user and render header meta
    await fetchProfileUser();
    }

    // Tab click handler
    function handleTabClick(tabElement, type) {
      // Remove active class from all tabs
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      // Add active class to clicked tab
      tabElement.classList.add('active');
      // Load characters
      loadCharacters(type, accessLevel);
    }

    // Set up tab event listeners
    if (!userID) {
      document.getElementById('myCharactersTab').addEventListener('click', () => {
        handleTabClick(document.getElementById('myCharactersTab'), 'mine');
      });
    
      document.getElementById('myFavoritesTab').addEventListener('click', () => {
        handleTabClick(document.getElementById('myFavoritesTab'), 'favorites');
      });
      
      if (document.getElementById('forReviewTab')) {
        document.getElementById('forReviewTab').addEventListener('click', () => {
          handleTabClick(document.getElementById('forReviewTab'), 'review');
        });
      }
    }

    // Main character loading function
    async function loadCharacters(type, accessLevel) {
    try {
      document.getElementById('characterGrid').innerHTML = "Loading...";
  
      // 1) Fetch all characters with error handling
      let allCharacters = [];
      try {
        const respChars = await fetch('https://chatcord-server.onrender.com/get-characters');
        if (respChars.ok) {
          const data = await respChars.json();
          allCharacters = Array.isArray(data) ? data : [];
        } else {
          console.error(`HTTP error: ${respChars.status}`);
        }
      } catch (error) {
        console.error('Fetch failed:', error);
      }
  
      // 2) Get the ids of favortited characters
      const myUserId = user?.id ?? null;
      
      // Search setup
      const searchInput = document.getElementById("searchBarCharacters");
      let searchQuery = searchInput.value.toLowerCase();

      let favoriteCharacterIds = new Set();
      if (myUserId && (type === 'favorites' || type === 'mine')) {
        try {
          const respInter = await fetch(
            `https://chatcord-server.onrender.com/user-interactions/${myUserId}`
          );
          const interactions = await respInter.json();
          interactions.forEach(({ character_id, interaction_type }) => {
            if (interaction_type === 'favorite') {
              favoriteCharacterIds.add(Number(character_id));
            }
          });
        } catch (error) {
          console.error('Failed to fetch interactions:', error);
        }
      }
  
      // 3) Filter characters (now safe with array)
      let charactersToDisplay = allCharacters.filter(character => {
        if (type !== 'mine' && type !== 'review' && character.review_status !== 'approved') {
          return false;
        }
        switch (type) {
          case 'mine': return character.userID === myUserId;
          case 'favorites': return favoriteCharacterIds.has(Number(character.id));
          case 'review': return character.review_status === 'pending';
          case 'user': return character.username === profileUser.username;
          default: return true;
        }
      });
      
      // Find matching character for initial search input
      const matchedChar = charactersToDisplay.find(char => char.id === charID);
      if (charID && matchedChar) {
        searchInput.value = matchedChar.char_name;
        searchQuery = matchedChar.char_name.toLowerCase();
      }
  
      // Filter characters
      let filteredCharacters = charactersToDisplay.filter(char => {
        // const isApproved = (char.review_status || "").toLowerCase() === "approved";
        const matchesSearch = char.char_name?.toLowerCase().includes(searchQuery);
        // Admins and mods can always see everything
        const isStaff = accessLevel === 'admin' || accessLevel === 'moderator';
        // Private check
        const canViewPrivate =
          isStaff ||                 // staff override
          !char.is_private ||        // not private
          char.userID === myUserId || // owner
          char.id === charID;        // accessed directly by ID
        // return isApproved && (searchQuery === "" || matchesSearch);
        return canViewPrivate && (searchQuery === "" || matchesSearch);
      });
  
      // Sorting
      const sortOption = document.getElementById("sortOptions").value;
      const sortOrder = document.getElementById("sortOrder").value;
      const multiplier = sortOrder === "asc" ? -1 : 1;
  
      filteredCharacters.sort((charA, charB) => {
        const getValue = (char, field) => parseInt(char[field], 10) || 0;
        
        switch (sortOption) {
          case "downloads":
            return multiplier * (getValue(charB, 'downloads') - getValue(charA, 'downloads'));
          case "likes":
            return multiplier * (getValue(charB, 'likes') - getValue(charA, 'likes'));
          case "comments":
            return multiplier * (getValue(charB, 'comments') - getValue(charA, 'comments'));
          case "favorites":
            return multiplier * (getValue(charB, 'favorites') - getValue(charA, 'favorites'));
          case "date":
            return multiplier * (new Date(charB.createdAt) - new Date(charA.createdAt));
          default:
            return 0;
        }
      });
  
      // 4) Sorting and rendering
      if (type === 'mine') {
        filteredCharacters.sort((a, b) => {
          if (a.review_status === 'request_changes') return -1;
          if (b.review_status === 'request_changes') return 1;
          return 0;
        });
      }
  
      const showFavBadge = (type === 'favorites');
      if (filteredCharacters.length === 0) {
        document.getElementById('characterGrid').innerHTML = 
           type === 'favorites' ? "You haven't favorited any characters yet." :
           type === 'mine' ? "You haven't created any characters yet." :
           type === 'review' ? "No characters pending review." :
           "No characters found.";
      } else {
        populateGrid(filteredCharacters, {
          showDetails: type !== 'mine',
          reviewMode: type === 'review',
          accessLevel: accessLevel,
          includeTags: [],
          excludeTags: []
        });
      }
    } catch (error) {
      console.error("Error loading characters:", error);
      document.getElementById('characterGrid').innerText = "Failed to load characters.";
    }
  }

  // Helper: render header meta (avatar + follower count or button)
  function renderHeaderMeta({ profile, isViewingOwn, isFollowing }) {
    const meta = document.getElementById('profileHeaderMeta');
    if (!profile) {
      meta.innerHTML = '';
      return;
    }

    const avatarUrl =  `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.png` || '/default-avatar.png';
    const followerCount = Number(profile.follower_count ?? 0);

    // base meta HTML: avatar + counts area
    meta.innerHTML = `
      <div class="avatar-small"><img src="${avatarUrl}" alt="avatar"></div>
      <div style="display:flex; flex-direction:column;">
        <div><strong id="followerCount">${followerCount}</strong> followers</div>
        <div id="followActionArea" style="margin-top:6px;"></div>
      </div>
    `;

    const actionArea = document.getElementById('followActionArea');

    // If viewing own profile: show only follower count (no buttons)
    if (isViewingOwn) {
      actionArea.innerHTML = ''; // nothing to add
      return;
    }

    // Not own profile: show follow/unfollow button if logged in
    if (!myUserId) {
      actionArea.innerHTML = ''; // not logged in => no follow button
      return;
    }

    // Create follow toggle button
    const btn = document.createElement('button');
    btn.className = 'follow-btn';
    btn.dataset.following = isFollowing ? '1' : '0';
    btn.textContent = isFollowing ? 'Unfollow' : 'Follow';
    if (isFollowing) btn.classList.add('unfollow');

    btn.onclick = async () => {
      btn.disabled = true;
      try {
        // Use your backend endpoints /follow and /unfollow
        const endpoint = (btn.dataset.following === '1') ? '/unfollow' : '/follow';
        const resp = await fetch(`https://chatcord-server.onrender.com${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          // NOTE: server should verify the authenticated user; client sends myUserId for convenience
          body: JSON.stringify({ follower_id: myUserId, followed_id: profile.id })
        });

        if (!resp.ok) {
          const text = await resp.text();
          console.error('Follow action failed:', text);
          alert('Failed to perform action.');
          return;
        }

        // Toggle UI state locally
        const newFollowing = btn.dataset.following === '1' ? '0' : '1';
        btn.dataset.following = newFollowing;
        const isNowFollowing = newFollowing === '1';
        btn.textContent = isNowFollowing ? 'Unfollow' : 'Follow';
        btn.classList.toggle('unfollow', isNowFollowing);

        // Update follower count shown (remember DB trigger keeps authoritative count)
        const fcEl = document.getElementById('followerCount');
        let current = Number(fcEl.innerText || 0);
        fcEl.innerText = isNowFollowing ? current + 1 : Math.max(0, current - 1);
      } catch (err) {
        console.error(err);
        alert('Network error');
      } finally {
        btn.disabled = false;
      }
    };

    actionArea.appendChild(btn);
  }

  // Fetch profile user (using extended endpoint so server returns follower_count and is_following)
  async function fetchProfileUser() {
    try {
      // If viewing someone else's profile
      if (userID) {
        // request extended info and pass viewer id (if available)
        const url = myUserId
          ? `https://chatcord-server.onrender.com/get-user-extended/${encodeURIComponent(userID)}?viewer_id=${encodeURIComponent(myUserId)}`
          : `https://chatcord-server.onrender.com/get-user-extended/${encodeURIComponent(userID)}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('Failed to fetch profile user');
        const data = await res.json();
        profileUser = data.user;
        const isFollowing = !!data.is_following;
  
        // Set header text
        const displayName = profileUser.displayname && profileUser.displayname.trim() !== ""
          ? profileUser.displayname
          : profileUser.username;
        const header = document.getElementById('profileHeader');
        header.innerHTML = `<span>${displayName}'s Profile</span>`;
  
        // Render meta: not own profile
        renderHeaderMeta({ profile: profileUser, isViewingOwn: myUserId === userID, isFollowing });
      } else {
        // Viewing own profile: fetch own user record (use extended endpoint for consistency)
        if (!myUserId) {
          // Not logged in and no u param: nothing to show
          profileUser = null;
          const header = document.getElementById('profileHeader');
          setProfileHeaderTitle('My');
          renderHeaderMeta({ profile: null, isViewingOwn: true, isFollowing: false });
          return;
        }
        const res = await fetch(`https://chatcord-server.onrender.com/get-user-extended/${encodeURIComponent(myUserId)}?viewer_id=${encodeURIComponent(myUserId)}`);
        if (!res.ok) throw new Error('Failed to fetch your user data');
        const data = await res.json();
        profileUser = data.user;

        const displayName = profileUser.displayname && profileUser.displayname.trim() !== ""
          ? profileUser.displayname
          : profileUser.username;
        const header = document.getElementById('profileHeader');
        setProfileHeaderTitle(escapeHtml(displayName));

        // Review Tab
        if (accessLevel === 'admin' || accessLevel === 'moderator') {
          const separator = document.createElement('span');
          separator.className = 'separator';
          separator.textContent = '|';
          
          const forReviewTab = document.createElement('span');
          forReviewTab.className = 'tab';
          forReviewTab.id = 'forReviewTab';
          forReviewTab.textContent = 'For Review';
          forReviewTab.addEventListener('click', () => loadCharacters('review', accessLevel));
          
          header.appendChild(separator);
          header.appendChild(forReviewTab);
        }
        
        // Render meta: own profile => show only follower count
        renderHeaderMeta({ profile: profileUser, isViewingOwn: true, isFollowing: false });
      }
    } catch (err) {
      console.error('Error fetching profile user:', err);
    }
  }

  function setProfileHeaderTitle(displayName) {
    const header = document.getElementById('profileHeader');
    // Try to reuse an existing title element, else create one
    let titleSpan = header.querySelector('#profileTitle');
    if (!titleSpan) {
      titleSpan = document.createElement('span');
      titleSpan.id = 'profileTitle';
      // Insert BEFORE the first tab so tabs keep their styling/behavior
      header.insertBefore(titleSpan, header.firstChild);
    }
    titleSpan.textContent = `${displayName}'s Profile`;
  }
  
  // small utility to escape text for safe insertion into HTML
  function escapeHtml(str) {
    if (!str) return '';
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }
  // Initial load
  if (userID) {
    // Viewing someone else's profile
    currentType = 'user';
    await loadCharacters(currentType, accessLevel);
  } else {
    // Viewing own profile
    if (accessLevel === 'admin' || accessLevel === 'moderator') {
      currentType = 'review';
      await loadCharacters(currentType, accessLevel);
      document.getElementById('forReviewTab').classList.add('active');
    } else {
      currentType = 'mine';
      await loadCharacters(currentType, accessLevel);
      document.getElementById('myCharactersTab').classList.add('active');
    }
  }

  // Character grid search bar
  document.getElementById("searchBarCharacters").addEventListener("input", () => {
    charID = null;
    loadCharacters(currentType, accessLevel);
  });
  document.getElementById("sortOptions").addEventListener("input", () => {
    loadCharacters(currentType, accessLevel);
  });
  document.getElementById("sortOrder").addEventListener("input", () => {
    loadCharacters(currentType, accessLevel);
  });
  
  // Close sidebar when clicking on the overlay
  document.getElementById('overlay').addEventListener('click', function() {
    document.getElementById('detailsPanel')?.remove();
    this.classList.remove('active');
  });

  </script>
</body>
</html>
